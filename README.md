# Проектная работа Base Python

По итогу выполнения проектной работы у вас будет
готовое веб-приложение с взаимодействием с БД и очередью задач. 
В проектной работе необходимо применить знания по таким темам как
сетевое взаимодействие,
проектирование таблиц и связей в БД, 
миграции схем БД, 
контейнеризация приложения.

## Цели проектной работы

Закрепить знания по работе с:
- Falcon API (WSGI приложение)
- Pydantic (валидация, сериализация, десериализация данных)
- SQLAlchemy (взаимодействие с базами данных)
- alembic (миграции схем баз данных)
- Docker (контейнеризация приложения)
- RabbitMQ (работа с очередями задач)


## Описание проектной работы
Создайте Falcon API приложение для онлайн-реестра книг.
В этом приложении должны присутствовать следующие сущности:
- Автор
- Издательство
- Книга
- Категория

Добавьте поддержку создания каждой из этих сущностей через POST запрос,
чтение списка сущностей и каждой отдельной сущности (где применимо) через GET.

Свяжите сущности (таблицы) между собой соответствующим типом связи.

Создайте миграции схем для каждой сущности (по миграции на каждую сущность, не меньше).

Создание новой сущности должно проходить через валидацию схемой Pydantic.

При создании новой сущности должна выполняться отправка уведомления
в очередь RabbitMQ с информацией о деталях новой сущности (тип, идентификатор, название).
Также должен быть создан отдельный скрипт, который собирает информацию
из очереди и выводит детали в консоль (подразумевается, 
что данный скрипт может быть доработан до отправки уведомлений на почту).

Добавьте возможность отфильтровать книгу по выбранным категориям. 
Для этого выполните обработку query string. При передаче параметров
фильтрации по тегам в запросе на получение списка книг должны возвращаться
соответствующие записи (для обработки параметров query string
можно использовать метод `get_param_as_list` или `get_param` 
из [Request](https://falcon.readthedocs.io/en/stable/_modules/falcon/request.html))

Соберите приложение в Docker контейнер. 

В корне проекта создайте отдельный скрипт `create_data.py`, 
который при выполнении наполняет все таблицы демонстрационными данными. 

## Технические требования к реализации проектной работы
- связь Автор-Книга один-ко-многим
- связь Книга-Издательство один-ко-многим
- связь Книга-Категория многие-ко-многим
- запросы данных из БД происходят оптимально,
дополнительные подгрузки не происходят при обращении к атрибутам связей 
- есть возможность запросить список тегов
- список тегов должен быть доступен по пути `/tags`
- есть возможность запросить список авторов и каждого автора по айди
- ресурсы авторов должны быть доступны по пути `/authors` и `/authors/{author_id}` 
- есть возможность запросить список издательств и каждое издательство по айди
- ресурсы издательств должны быть доступны по пути `/publishers` и `/publishers/{publisher_id}` 
- есть возможность запросить список книг, каждую книгу по айди, книги автора, книги издательства
- ресурсы книг должны быть доступны по пути `/books` и `/books/{book_id}`. 
Также книги по определенному автору должны быть доступны по пути `/authors/{author_id}/books`,
а книги по определенному издательству должны быть доступны по пути `/publishers/{publisher_id}/books`
- в ответ на запрос на получение списка книг или выбранной книги возвращаются и теги 
- реализован поиск книг по тегам (при запросе на список книг, 
а также при запросе на список книг автора и книг издательства.  
Для обработки параметров query string можно использовать метод `get_param_as_list` или `get_param` 
из [Request](https://falcon.readthedocs.io/en/stable/_modules/falcon/request.html)) 
- создание новых сущностей должно проходить через валидацию схемой Pydantic. 
Входящий JSON должен быть обработан схемой Pydantic
(для каждой сущности должна быть создана схема для создания), 
из схемы данные должны быть переданы в модель SQLAlchemy
- сериализация данных для возврата в ответ на запрос должна быть 
реализована через схемы Pydantic (подсказка:
можно создать схему `[Item]SchemaIn(BaseModel)` для валидации данных при создании сущности
и `[Item]SchemaOut([Item]SchemaIn)` для сериализации данных для возврата ответа на запрос,
добавив в эту схему поля, доступные только для чтения (например, поле `id`))
- создана базовая модель SQLAlchemy
- модели SQLAlchemy разнесены по отдельным модулям в пакете models
- созданы миграции alembic
- миграции alembic не объединяют в себе создание нескольких таблиц. 
Одна миграция должна включать в себя создание не более одной таблицы
- создано ПО промежуточного слоя для отправки уведомлений о создании новых сущностей 
(хорошим вариантом будет создать в данном middleware все методы для разных сущностей,
а в запросе делать один вызов через `req.context...`) 
- создан скрипт для сбора данных из очереди. Данный скрипт должен выводить всю информацию в консоль
- создан скрипт для создания демонстрационного набора данных
- зависимости заморожены в файл requirements.txt
- приложение собрано в Docker контейнер 
(установка зависимостей должна происходить до копирования всего приложения)

